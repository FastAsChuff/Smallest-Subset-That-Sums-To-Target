#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <time.h>

// gcc largestsubsetsumtok2.c -o largestsubsetsumtok2.bin -O3 -march=native -Wall 
#define RESULTS_TYPE uint8_t
#define RESULTS_MAX 255

void printarray(int64_t *arr, int64_t arrsize) {  
  int64_t i, sum=0;
  for (i=0; i<arrsize; i++) {
    sum += arr[i];
    printf("%li ", arr[i]);
  }
  printf("\nSum = %li\n", sum);
  return;
}

RESULTS_TYPE **maxsubsetsumsize_init(int16_t arrsize, int64_t max_target_sum) {
  /* Create zeroed array results[k][j] representing the minimum subset size of the first k elements which sums to j  
     results[k][j] = 0 means target sum not possible
     results[k][j] = RESULTS_MAX means value not yet set
     results[k][j] = RESULTS_MAX - 1 means value >= RESULTS_MAX - 1
  */
  RESULTS_TYPE **results = malloc(((int32_t)arrsize+1)*sizeof(RESULTS_TYPE*));
  results[0] = malloc((max_target_sum+1) * sizeof(RESULTS_TYPE));
  results[0][0] = 0;
  for (int64_t i=1; i<=max_target_sum; i++) results[0][i] = RESULTS_MAX;
  for (int i=1; i<=arrsize; i++) {
    results[i] = malloc((max_target_sum+1) * sizeof(RESULTS_TYPE));
    memcpy(results[i], results[0], (max_target_sum+1) * sizeof(RESULTS_TYPE));
  }  
  return results;  
}

void maxsubsetsumsize_free(RESULTS_TYPE **results, int16_t arrsize) {
  for (int16_t i=0; i<=arrsize; i++) free(results[i]);
  free(results);
}

void printresultsarray(RESULTS_TYPE **results, int64_t arrsize, int64_t max_target_sum) {  
  int64_t i,j;
  for (j=1; j<=max_target_sum; j++) {
    printf("%03li ", j);
  }
  printf("\n");
  for (i=1; i<=arrsize; i++) {
    for (j=1; j<=max_target_sum; j++) {
      printf("%03i ", results[i][j]);
    }
    printf("\n");
  }
  printf("\n");
  return;
}

void popresultsarray(RESULTS_TYPE **results, int64_t *arr, int16_t arrsize, int64_t max_target_sum) {
  int64_t j, arrk;
  int16_t k;
  int16_t result, result1, result2;
  for (j=1; j<=max_target_sum; j++) {
    results[1][j] = 0;
  }
  if (arr[0] <= max_target_sum) results[1][arr[0]] = 1;
  for (k=2; k<=arrsize; k++) {
    arrk = arr[k-1];
    for (j=1; j<=max_target_sum; j++) {
      result1 = results[k-1][j];  // largest subset size with sum j from first k-1 elements
      if (j > arrk) {
        result = results[k-1][j - arrk];
        result2 = (result ? 1+result : 0);
      } else {
        if (j == arrk) {
          result2 = 1;
        } else {
          result2 = 0;
        }
      }
      result = (result1 < result2 ? result2 : result1);
      results[k][j] = (result < RESULTS_MAX ? result : RESULTS_MAX - 1);
    }
  }
}

int64_t *findsubset(RESULTS_TYPE **results, int64_t *arr, int16_t arrsize, int64_t target_sum) {
// Returns subset of maximal size with element sum equal to target_sum or NULL if target_sum not acheivable.
  int16_t result = results[arrsize][target_sum];
  if (result == 0) return NULL;
  if (result >= RESULTS_MAX - 1) return NULL;
  int16_t k, result1=result;
  int64_t *subset = calloc(result, sizeof(int64_t));
  k = arrsize-1;
  while (result) {
    if (k > 0) result1 = results[k][target_sum];
    if ((k == 0) || (result1 < result)) {
      target_sum -= arr[k];
      result--;
      subset[result] = arr[k];
    }
    k--;
  }
  return subset;
};

int main(int argc, char*argv[]) {
  if (argc <= 4) {
    printf("This program finds a maximally sized subset of a set of n positive integers 0 < a_i < 2^63 which has a target element sum k using dynamic programming.\n");
    printf("Space and time complexity is approx. O(nk).\n");
    printf("Author: Simon Goater Mar 2024.\n");
    printf("Usage: %s maxbytes n k a1 ... an\n", argv[0]);
    printf("maxbytes is the maximum size of the internal matrix generated by the calculation in RAM.\n2*(n+1)*(k+1) <= maxbytes < 2^63\n");
    printf("1 <= k < 2^63\n");
    printf("1 <= n <= 32000\n");
    exit(0);
  }
  int64_t maxresultsbytes = atol(argv[1]);
  if (maxresultsbytes <= 0) {
    fprintf(stderr, "%s - Invalid maxbytes!!\n", argv[0]);
    exit(1);
  }
  int32_t arrsize = atoi(argv[2]);
  if (((4+arrsize) != argc) || (arrsize > 32000)) {
    fprintf(stderr, "%s - Invalid array size!!\n", argv[0]);
    exit(1);
  }
  int64_t target_sum = atol(argv[3]);
  if (target_sum <= 0) {
    fprintf(stderr, "%s - Invalid target sum!!\n", argv[0]);
    exit(1);
  }
  int64_t *arr = malloc(arrsize*sizeof(int64_t));
  __int128 arrsum = 0;
  int32_t j = 0;
  for (int32_t i=0; i<arrsize; i++) {
    arr[j] = atol(argv[4+i]);
    if (arr[j] <= 0) {
      free(arr);
      fprintf(stderr, "%s - Invalid array element!!\n", argv[0]);
      exit(1);      
    } else {
      if (arr[j] < target_sum) {
        arrsum += arr[j];
        j++;
      }
    }
  }
  arrsize = j; // Re-adjust arrsize after removing elements greater than target_sum.
  if (arrsum < target_sum) {
    free(arr);
    printf("No solution.\n");
    exit(0);    
  }
  if (arrsum == target_sum) {
    printf("Max. subset size which sums to %li is %i\n", target_sum, arrsize);
    printarray(arr, arrsize);
    free(arr);
    exit(0);      
  }
  __int128 resultsbytes = ((__int128)(arrsize+1)*(target_sum+1))*sizeof(RESULTS_TYPE);
  if (resultsbytes > maxresultsbytes) {
    free(arr);
    fprintf(stderr, "%s - Matrix Too Big!! %li required, %li allowed.\n", argv[0], (int64_t)resultsbytes, maxresultsbytes);
    exit(1);
  }
  RESULTS_TYPE **results = maxsubsetsumsize_init(arrsize, target_sum);
  printf("Using array of %li bytes\n", (int64_t)resultsbytes);
  popresultsarray(results, arr, arrsize, target_sum);
  RESULTS_TYPE result = results[arrsize][target_sum];
  //printresultsarray(results, arrsize, target_sum);
  if (result > 0) {
    if (result == RESULTS_MAX) {
      printf("ERROR! - Can't find array result!\n.");
    } else {
      if (result == (RESULTS_MAX-1)) {
        printf("Max. subset size which sums to %li is at least %i\n", target_sum, result);
      } else {    
        printf("Max. subset size which sums to %li is %i\n", target_sum, result);
        int64_t *subset = findsubset(results, arr, arrsize, target_sum);
        if (subset == NULL) {
          printf("ERROR! - Can't find subset!\n.");
        } else {
          printarray(subset, result);
          free(subset);
        }
      }
    }
  } else {
    printf("No solution.\n");
  }
  free(arr);
  maxsubsetsumsize_free(results, arrsize);
}
