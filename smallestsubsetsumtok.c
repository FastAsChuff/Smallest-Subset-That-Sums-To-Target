#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <time.h>

// gcc smallestsubsetsumtok.c -o smallestsubsetsumtok.bin -O3 -march=native -Wall 

void printarray(int64_t *arr, int64_t arrsize) {  
  int64_t i, sum=0;
  for (i=0; i<arrsize; i++) {
    sum += arr[i];
    printf("%li ", arr[i]);
  }
  printf("\nSum = %li\n", sum);
  return;
}

int16_t **minsubsetsumsize_init(int16_t arrsize, int64_t max_target_sum) {
  /* Create zeroed array results[k][j] representing the minimum subset size of the first k elements which sums to j  
     results[k][j] = 0 means value not yet set
     results[k][j] > arrsize means target sum not possible
  */
  int16_t **results = malloc(((int32_t)arrsize+1)*sizeof(int16_t*));
  if (results == NULL) return NULL;
  for (int16_t i=0; i<=arrsize; i++) {
    results[i] = calloc(max_target_sum+1, sizeof(int16_t));
    if (results[i] == NULL) {
      for (int16_t j=i-1; j>=0; j--) free(results[j]);
      return NULL;
    }
  }  
  return results;  
}

void minsubsetsumsize_free(int16_t **results, int16_t arrsize) {
  for (int i=0; i<=arrsize; i++) free(results[i]);
  free(results);
}

void popresultsarray(int16_t **results, int64_t *arr, int16_t arrsize, int64_t max_target_sum) {
  int64_t j;
  int16_t k, kk;
  int16_t result1, result2;
  for (j=1; j<=max_target_sum; j++) {
    results[1][j] = arrsize+1;
  }
  for (k=0; k<arrsize; k++) {
    if (arr[k] <= max_target_sum) {
      for (kk=k+1; kk<=arrsize; kk++) results[kk][arr[k]] = 1;
    }
  }
  for (k=1; k<=arrsize; k++) {
    for (j=1; j<=max_target_sum; j++) {
      if (results[k][j] == 0) {
        result1 = results[k-1][j];
        if (j > arr[k-1]) {
          result2 = 1+results[k-1][j - arr[k-1]];
        } else {
          result2 = arrsize+1;
        }
        results[k][j] = (result1 < result2 ? result1 : result2);
      }
    }
  }
}

int64_t *findsubset(int16_t **results, int64_t *arr, int16_t arrsize, int64_t target_sum) {
// Returns subset of minimal size with element sum equal to target_sum or NULL if target_sum not acheivable.
  int16_t result = results[arrsize][target_sum];
  if (result > arrsize) return NULL;
  int16_t k, result1=result;
  int64_t *subset = calloc(result, sizeof(int64_t));
  if (subset == NULL) return NULL;
  k = arrsize-1;
  while (result) {
    if (k > 0) result1 = results[k][target_sum];
    if ((k == 0) || (result1 > result)) {
      target_sum -= arr[k];
      result--;
      subset[result] = arr[k];
    }
    k--;
  }
  return subset;
};


int main(int argc, char*argv[]) {
  if (argc <= 4) {
    printf("This program finds a minimally sized subset of a set of n positive integers 0 < a_i < 2^63 which has a target element sum k using dynamic programming.\n");
    printf("If there are no solutions that sum to the target, then it solves for the largest k below the original target.\n");
    printf("Space and time complexity is approx. O(nk).\n");
    printf("Author: Simon Goater Mar 2024.\n");
    printf("Usage: %s maxbytes n k a1 ... an\n", argv[0]);
    printf("maxbytes is the maximum size of the internal matrix generated by the calculation in RAM.\n2*(n+1)*(k+1) <= maxbytes < 2^63\n");
    printf("1 <= k < 2^63\n");
    printf("1 <= n <= 32000\n");
    exit(0);
  }
  int64_t maxresultsbytes = atol(argv[1]);
  if (maxresultsbytes <= 0) {
    fprintf(stderr, "%s - Invalid maxbytes!!\n", argv[0]);
    exit(1);
  }
  int32_t arrsize = atoi(argv[2]);
  if (((4+arrsize) != argc) || (arrsize > 32000)) {
    fprintf(stderr, "%s - Invalid array size!!\n", argv[0]);
    exit(1);
  }
  int64_t target_sum = atol(argv[3]);
  if (target_sum <= 0) {
    fprintf(stderr, "%s - Invalid target sum!!\n", argv[0]);
    exit(1);
  }
  int64_t *arr = malloc(arrsize*sizeof(int64_t));
  __int128 arrsum = 0;
  int64_t j = 0;
  for (int32_t i=0; i<arrsize; i++) {
    arr[j] = atol(argv[4+i]);
    if (arr[j] <= 0) {
      free(arr);
      fprintf(stderr, "%s - Invalid array element!!\n", argv[0]);
      exit(1);      
    } else {
      if (arr[j] == target_sum) {
        printf("Min. subset size which sums to %li is 1\n", target_sum);
        printf("%li\n", target_sum);
        printf("Sum = %li\n", target_sum);
        free(arr);
        exit(0);      
      }
      if (arr[j] < target_sum) {
        arrsum += arr[j];
        j++;
      }
    }
  }
  arrsize = j; // Re-adjust arrsize after removing elements greater than target_sum.
  if (arrsum < target_sum) {
    free(arr);
    printf("No solution.\n");
    exit(0);    
  }
  __int128 resultsbytes = ((__int128)(arrsize+1)*(target_sum+1))*sizeof(int16_t);
  if (resultsbytes > maxresultsbytes) {
    free(arr);
    fprintf(stderr, "%s - Matrix Too Big!! %li required, %li allowed.\n", argv[0], (int64_t)resultsbytes, maxresultsbytes);
    exit(1);
  }
  int16_t **results = minsubsetsumsize_init(arrsize, target_sum);
  int16_t result;
  if (results == NULL) {
    printf("Error allocating memory!\n");
    free(arr);
    exit(1);
  }
  printf("Using array of %li bytes\n", (int64_t)resultsbytes);
  popresultsarray(results, arr, arrsize, target_sum);
  for (j=target_sum; j > 0; j--) {
    result = results[arrsize][j];
    if (result <= arrsize) break;
  }
  if (result <= arrsize) {
    if (j == target_sum) {
      printf("Min. subset size which sums to %li is %i\n", target_sum, result);
    } else {
      printf("No solution to target %li.\n", target_sum);
      printf("Largest target below %li with a solution is %li which has minimum subset size %i.\n", target_sum, j, result);
    }
    int64_t *subset = findsubset(results, arr, arrsize, j);
    if (subset == NULL) {
      printf("Error finding example subset!\n");
    } else {
      printarray(subset, result);
      free(subset);
    }
  } else {
    printf("No solution.\n");
  }
  free(arr);
  minsubsetsumsize_free(results, arrsize);
}
/*
time ./smallestsubsetsumtok.bin 100000000 20 54321 1432 23343 4433 6444 955 5535 223 7675 666 3111 4001 3232 788 2212 888 449 6543 211 6996 3197
Using array of 2281524 bytes
Min. subset size which sums to 54321 is 8
23343 4433 5535 7675 3111 3232 449 6543 
Sum = 54321

real	0m0.009s
user	0m0.000s
sys	0m0.009s

time ./smallestsubsetsumtok.bin 2000000000 200 9999 [list of first 200 primes]
Using array of 4020000 bytes
Min. subset size which sums to 9999 is 9
1087 1091 1093 1097 1109 1117 1123 1129 1153 
Sum = 9999

real	0m0.015s
user	0m0.009s
sys	0m0.005s

time ./smallestsubsetsumtok.bin 2500000000 500 2222222 [list of first 500 squares]
Using array of 2226667446 bytes
Min. subset size which sums to 2222222 is 10
185761 219961 222784 223729 224676 225625 228484 229441 230400 231361 
Sum = 2222222

real	0m4.053s
user	0m2.731s
sys	0m1.306s
*/
